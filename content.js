/**
 * content.js
 * Applies custom styles, potentially generated by AI.
 * Includes logic for site-specific themes, enable/disable toggle,
 * and communication with the popup for getting context and applying new styles.
 */

const STYLE_ID = "hacker-theme-style";
const FONT_ID = "hacker-theme-font-link"; // Keep font injection if desired

// Function to ensure the style element exists and has content
function ensureStyleElementExists() {
  let styleElement = document.getElementById(STYLE_ID);
  if (!styleElement) {
    console.log("Style element not found, creating and adding to head.");
    styleElement = document.createElement("style");
    styleElement.id = STYLE_ID;
    // Load the last saved theme for this site ONCE during creation
    const hostname = window.location.hostname;
    const siteThemeKey = `${hostname}-theme`; // Simplified key
    const storedTheme = localStorage.getItem(siteThemeKey) || ""; // Default to empty string

    console.log(
      `Loading initial theme for ${hostname} from localStorage key: ${siteThemeKey}`,
      storedTheme ? `(${storedTheme.length} chars)` : "(empty)"
    );
    styleElement.innerHTML = storedTheme;
    document.head.appendChild(styleElement);
    // Show notification only if a theme was actually loaded
    if (storedTheme.trim().length > 0) {
      showNotification("Custom style applied!");
    }
  }
  return styleElement;
}

// Function to enable or disable the custom styles
function setCustomStylesEnabled(enabled) {
  const action = enabled ? "ENABLE" : "DISABLE";
  console.log(`Attempting to ${action} custom styles...`);
  const styleElement = ensureStyleElementExists(); // Ensure it exists before trying to modify
  if (styleElement) {
    styleElement.disabled = !enabled; // Set disabled to the opposite of enabled
    console.log(`Custom styles ${action}D (style element disabled=${!enabled}).`);
  } else {
    console.error(`Failed to find or create style element for ${action.toLowerCase()}ing.`);
  }
}

// Function to apply new styles and save them
function applyAndSaveStyles(newStyles) {
  console.log(
    "[applyAndSaveStyles] Called with styles:",
    newStyles ? newStyles.substring(0, 100) + "..." : "(empty)"
  );
  try {
    const styleElement = ensureStyleElementExists();
    if (styleElement && typeof newStyles === "string") {
      console.log("Applying generated styles...");
      styleElement.innerHTML = newStyles;

      // Save the new theme to localStorage for persistence
      const hostname = window.location.hostname;
      const siteThemeKey = `${hostname}-theme`;
      localStorage.setItem(siteThemeKey, newStyles);
      console.log(`New theme saved to localStorage key: ${siteThemeKey}`);

      // Ensure styles are enabled after applying
      styleElement.disabled = false;
      // Also update the toggle state in storage to reflect styles being enabled
      chrome.storage.local.set({ stylesDisabled: false });

      showNotification("Custom style applied!"); // Show notification on successful application
      console.log(
        "[applyAndSaveStyles] Styles applied and saved successfully."
      );
      return true;
    } else {
      console.error(
        "[applyAndSaveStyles] Failed: Style element not found or invalid styles provided."
      );
      return false;
    }
  } catch (error) {
    console.error("[applyAndSaveStyles] Error during execution:", error);
    return false;
  }
}
// Function to show a notification tooltip
function showNotification(message) {
  const notificationId = "style-changer-notification";
  // Remove existing notification if any
  const existingNotification = document.getElementById(notificationId);
  if (existingNotification) {
    existingNotification.remove();
  }

  const notification = document.createElement("div");
  notification.id = notificationId;
  notification.textContent = message;

  // Styles inspired by popup.html :root variables
  Object.assign(notification.style, {
    position: "fixed",
    top: "20px",
    right: "20px",
    backgroundColor: "#282828", // --md-surface
    color: "#eff", // --md-text
    padding: "12px 20px",
    borderRadius: "12px", // --md-radius
    zIndex: "99999", // Ensure it's on top
    fontSize: "0.94rem", // Match popup setting-label
    fontFamily: '"Roboto", system-ui, sans-serif', // --md-font
    boxShadow: "0 2px 12px 0 rgba(0, 0, 0, 0.25)", // --md-shadow
    border: "1px solid #333", // --md-border
    opacity: "0", // Start fully transparent
    transition: "opacity 0.5s ease-in-out", // Fade in/out effect
  });

  document.body.appendChild(notification);

  // Trigger fade in
  setTimeout(() => {
    notification.style.opacity = "1";
  }, 10); // Small delay to allow transition

  // Set timeout to fade out and remove the notification after 3 seconds
  setTimeout(() => {
    notification.style.opacity = "0";
    // Remove element after fade out transition completes
    setTimeout(() => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, 500); // Match transition duration
  }, 3000);
}

// --- Helper Function to Sanitize HTML (Remove Text Content) ---
function getSanitizedHTMLStructure() {
  if (!document.body) {
    console.error("Document body not found for sanitization.");
    return null;
  }

  // Clone the body to avoid modifying the live DOM
  const clonedBody = document.body.cloneNode(true);

  // Tags inside which text nodes should be preserved
  const preserveTextTags = new Set([
    "SPAN",
    "DIV",
    "A",
    "P",
    "LI",
    "BUTTON",
    "H1",
    "H2",
    "H3",
    "H4",
    "H5",
    "H6",
    "SECTION",
    "ARTICLE",
    "HEADER",
    "FOOTER",
    "NAV",
    "MAIN",
  ]);

  // Recursive function to remove non-whitespace text nodes except inside preserveTextTags
  function removeTextNodes(node) {
    if (!node) return;

    const childNodes = Array.from(node.childNodes); // Create static array
    childNodes.forEach((child) => {
      if (child.nodeType === Node.TEXT_NODE) {
        // Remove text node if it contains non-whitespace characters and parent tag is NOT in preserveTextTags
        if (
          child.textContent.trim().length > 0 &&
          !preserveTextTags.has(child.parentNode.tagName)
        ) {
          node.removeChild(child);
        }
      } else if (child.nodeType === Node.ELEMENT_NODE) {
        // Recursively process element nodes
        // Skip script and style tags to avoid removing their content
        if (
          child.tagName !== "SCRIPT" &&
          child.tagName !== "STYLE" &&
          child.tagName !== "NOSCRIPT" &&
          child.tagName !== "META"
        ) {
          removeTextNodes(child);
        }
      }
    });
  }

  // Start the removal process on the cloned body
  removeTextNodes(clonedBody);

  // Helper to sanitize attributes that may contain sensitive data
  function sanitizeAttributes(node) {
    if (!node) return;
    if (node.nodeType === Node.ELEMENT_NODE) {
      // List of attributes to sanitize
      const attrsToSanitize = ["src", "href", "alt", "value", "placeholder"];
      // Preserve aria-label and title attributes for context
      const attrsToPreserve = new Set(["aria-label", "title"]);

      Array.from(node.attributes).forEach((attr) => {
        const name = attr.name.toLowerCase();
        if (attrsToSanitize.includes(name) && !attrsToPreserve.has(name)) {
          node.setAttribute(name, `[sanitized-${name}]`);
        }
      });

      // Recursively sanitize child elements
      Array.from(node.children).forEach((child) => sanitizeAttributes(child));
    }
  }

  // Sanitize attributes on the cloned body
  sanitizeAttributes(clonedBody);

  // Return the innerHTML of the sanitized clone
  return clonedBody.innerHTML;
}

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log("Message received in content script:", request.action);

  if (request.action === "toggleStyles") {
    setCustomStylesEnabled(request.enabled); // Use the new function
    sendResponse({ status: `Custom styling ${request.enabled ? 'enabled' : 'disabled'}` });
    return false; // Synchronous response
  } else if (request.action === "processRestyle") {
    console.log("Action: processRestyle");
    const promptText = request.prompt;
    console.log("Prompt: ", promptText);
    // Use an immediately-invoked async function to handle the fetch and response
    (async () => {
      try {
        // 1. Get context locally
        const styleElement = ensureStyleElementExists();
        const currentCSS = styleElement ? styleElement.innerHTML : "";
        // Still using innerHTML, but now it doesn't need to cross the message boundary
        // const currentHTML = document.body ? document.body.innerHTML : ""; // Original
        const currentHTML = getSanitizedHTMLStructure(); // Get sanitized HTML
        console.log(
          `Local context: CSS length ${currentCSS.length}, HTML length ${currentHTML.length}`
        );

        if (!currentHTML) {
          throw new Error("Could not get HTML content from page.");
        }

        const payload = {
          prompt: promptText,
          html_structure: currentHTML,
        };
        console.log("Payload object:", payload);
        // --- End Debugging ---
        const serverResponse = await fetch("http://localhost:8000/restyle", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(payload), // Use the logged payload object
        });

        if (!serverResponse.ok) {
          const errorData = await serverResponse
            .json()
            .catch(() => ({ detail: "Unknown server error" }));
          throw new Error(
            `Server error: ${serverResponse.status} - ${
              errorData.detail || "Failed to fetch"
            }`
          );
        }

        const data = await serverResponse.json();
        const generatedStyle = data.generated_style;

        if (!generatedStyle) {
          throw new Error("Server did not return generated styles.");
        }

        // 3. Apply the styles
        console.log("Applying styles received from server...");
        if (applyAndSaveStyles(generatedStyle)) {
          sendResponse({ status: "success" }); // Send success back to popup
        } else {
          throw new Error("Failed to apply styles locally.");
        }
      } catch (error) {
        console.error("Error during processRestyle:", error);
        sendResponse({ error: error.message }); // Send error back to popup
      }
    })(); // End of async IIFE

    return true; // Indicate asynchronous response
  } else if (request && request.action === "updateCustomStyles") {
    const css = request.css || "";
    const success = applyAndSaveStyles(css);
    if (success) {
      // Ensure styles are enabled after manual update
      setCustomStylesEnabled(true); // Use the new function
      sendResponse({ status: "success" });
    } else {
      sendResponse({ error: "Failed to apply custom styles." });
    }
    return true; // Indicate asynchronous response for updateCustomStyles
  } else {
    console.log("Unknown action received:", request.action);
    // Optional: send a response for unknown actions
    // sendResponse({ error: "Unknown action" });
    return false; // Synchronous response (or no response needed)
  }
});

// --- Initialization ---
// Ensure the style element exists on script load
console.log("Initializing content script...");
ensureStyleElementExists(); // Call this first to create/load the element

// Set initial state based on storage
chrome.storage.local.get(["stylesEnabled"], (result) => { // Changed from stylesDisabled
  // Default to true (enabled) if not explicitly set or if stylesDisabled was used previously
  const isEnabled = typeof result.stylesEnabled === 'boolean' ? result.stylesEnabled : true;
  setCustomStylesEnabled(isEnabled); // Use the new function for initialization
});
