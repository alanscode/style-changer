/**
 * content.js
 * Applies custom styles, potentially generated by AI.
 * Includes logic for site-specific themes, enable/disable toggle,
 * and communication with the popup for getting context and applying new styles.
 */

const STYLE_ID = "hacker-theme-style";
const FONT_ID = "hacker-theme-font-link"; // Keep font injection if desired

// Function to ensure the style element exists and has content
function ensureStyleElementExists() {
  let styleElement = document.getElementById(STYLE_ID);
  if (!styleElement) {
    console.log("Style element not found, creating and adding to head.");
    styleElement = document.createElement("style");
    styleElement.id = STYLE_ID;
    // Load the last saved theme for this site ONCE during creation
    const hostname = window.location.hostname;
    const siteThemeKey = `${hostname}-theme`; // Simplified key
    const storedTheme = localStorage.getItem(siteThemeKey) || ""; // Default to empty string

    console.log(
      `Loading initial theme for ${hostname} from localStorage key: ${siteThemeKey}`
    );
    styleElement.innerHTML = storedTheme;
    document.head.appendChild(styleElement);
  }
  return styleElement;
}

// Function to enable the custom styles (by enabling the style element)
function enableCustomStyles() {
  console.log("Attempting to ENABLE custom styles...");
  const styleElement = ensureStyleElementExists();
  if (styleElement) {
    styleElement.disabled = false;
    console.log("Custom styles ENABLED (style element disabled=false).");
  } else {
    console.error("Failed to find or create style element for enabling.");
  }
}

// Function to disable the custom styles (by disabling the style element)
function disableCustomStyles() {
  console.log("Attempting to DISABLE custom styles...");
  const styleElement = ensureStyleElementExists(); // Ensure it exists before trying to disable
  if (styleElement) {
    styleElement.disabled = true;
    console.log("Custom styles DISABLED (style element disabled=true).");
  } else {
    console.log("Style element not found, cannot disable.");
  }
}

// Function to apply new styles and save them
function applyAndSaveStyles(newStyles) {
  console.log(
    "[applyAndSaveStyles] Called with styles:",
    newStyles ? newStyles.substring(0, 100) + "..." : "(empty)"
  );
  try {
    const styleElement = ensureStyleElementExists();
    if (styleElement && typeof newStyles === "string") {
      console.log("Applying generated styles...");
      styleElement.innerHTML = newStyles;

      // Save the new theme to localStorage for persistence
      const hostname = window.location.hostname;
      const siteThemeKey = `${hostname}-theme`;
      localStorage.setItem(siteThemeKey, newStyles);
      console.log(`New theme saved to localStorage key: ${siteThemeKey}`);

      // Ensure styles are enabled after applying
      styleElement.disabled = false;
      // Also update the toggle state in storage to reflect styles being enabled
      chrome.storage.local.set({ stylesDisabled: false });

      console.log(
        "[applyAndSaveStyles] Styles applied and saved successfully."
      );
      return true;
    } else {
      console.error(
        "[applyAndSaveStyles] Failed: Style element not found or invalid styles provided."
      );
      return false;
    }
  } catch (error) {
    console.error("[applyAndSaveStyles] Error during execution:", error);
    return false;
  }
}
// --- Helper Function to Sanitize HTML (Remove Text Content) ---
function getSanitizedHTMLStructure() {
  if (!document.body) {
    console.error("Document body not found for sanitization.");
    return null;
  }

  // Clone the body to avoid modifying the live DOM
  const clonedBody = document.body.cloneNode(true);

  // Recursive function to remove non-whitespace text nodes
  function removeTextNodes(node) {
    if (!node) return;

    const childNodes = Array.from(node.childNodes); // Create static array
    childNodes.forEach((child) => {
      if (child.nodeType === Node.TEXT_NODE) {
        // Remove text node if it contains non-whitespace characters
        if (child.textContent.trim().length > 0) {
          node.removeChild(child);
        }
      } else if (child.nodeType === Node.ELEMENT_NODE) {
        // Recursively process element nodes
        // Skip script and style tags to avoid removing their content
        if (child.tagName !== "SCRIPT" && child.tagName !== "STYLE") {
          removeTextNodes(child);
        }
      }
    });
  }

  // Start the removal process on the cloned body
  removeTextNodes(clonedBody);

  // Helper to sanitize attributes that may contain sensitive data
  function sanitizeAttributes(node) {
    if (!node) return;
    if (node.nodeType === Node.ELEMENT_NODE) {
      // List of attributes to sanitize
      const attrsToSanitize = [
        "src",
        "href",
        "alt",
        "value",
        "placeholder",
        "title",
      ];
      attrsToSanitize.forEach((attr) => {
        if (node.hasAttribute && node.hasAttribute(attr)) {
          node.setAttribute(attr, `[sanitized-${attr}]`);
        }
      });
      // Recursively sanitize child elements
      Array.from(node.children).forEach((child) => sanitizeAttributes(child));
    }
  }

  // Sanitize attributes on the cloned body
  sanitizeAttributes(clonedBody);

  // Return the innerHTML of the sanitized clone
  return clonedBody.innerHTML;
}

// Listen for messages from the popup
// Make the listener async to handle fetch
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log("Message received in content script:", request.action);

  if (request.action === "toggleStyles") {
    if (request.enabled) {
      enableCustomStyles();
      sendResponse({ status: "Custom styling enabled" });
    } else {
      disableCustomStyles();
      sendResponse({ status: "Custom styling disabled" });
    }
    return false; // Synchronous response
  } else if (request.action === "processRestyle") {
    console.log("Action: processRestyle");
    const promptText = request.prompt;

    // Use an immediately-invoked async function to handle the fetch and response
    (async () => {
      try {
        // 1. Get context locally
        const styleElement = ensureStyleElementExists();
        const currentCSS = styleElement ? styleElement.innerHTML : "";
        // Still using innerHTML, but now it doesn't need to cross the message boundary
        // const currentHTML = document.body ? document.body.innerHTML : ""; // Original
        const currentHTML = getSanitizedHTMLStructure(); // Get sanitized HTML
        console.log(
          `Local context: CSS length ${currentCSS.length}, HTML length ${currentHTML.length}`
        );

        if (!currentHTML) {
          throw new Error("Could not get HTML content from page.");
        }

        // 2. Call the backend server
        console.log("Contacting server from content script...");
        // --- Debugging: Log data before sending ---
        console.log("Data being sent to server:");
        console.log("Prompt:", promptText);
        console.log(
          "HTML Structure (first 500 chars):",
          currentHTML ? currentHTML.substring(0, 500) : "null or empty"
        );
        const payload = {
          prompt: promptText,
          html_structure: currentHTML,
        };
        console.log("Payload object:", payload);
        // --- End Debugging ---
        const serverResponse = await fetch("http://localhost:8000/restyle", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(payload), // Use the logged payload object
        });

        if (!serverResponse.ok) {
          const errorData = await serverResponse
            .json()
            .catch(() => ({ detail: "Unknown server error" }));
          throw new Error(
            `Server error: ${serverResponse.status} - ${
              errorData.detail || "Failed to fetch"
            }`
          );
        }

        const data = await serverResponse.json();
        const generatedStyle = data.generated_style;

        if (!generatedStyle) {
          throw new Error("Server did not return generated styles.");
        }

        // 3. Apply the styles
        console.log("Applying styles received from server...");
        if (applyAndSaveStyles(generatedStyle)) {
          sendResponse({ status: "success" }); // Send success back to popup
        } else {
          throw new Error("Failed to apply styles locally.");
        }
      } catch (error) {
        console.error("Error during processRestyle:", error);
        sendResponse({ error: error.message }); // Send error back to popup
      }
    })(); // End of async IIFE

    return true; // Indicate asynchronous response
  } else if (request && request.action === "updateCustomStyles") {
    const css = request.css || "";
    const success = applyAndSaveStyles(css);
    if (success) {
      sendResponse({ status: "success" });
    } else {
      sendResponse({ error: "Failed to apply custom styles." });
    }
    return true; // Indicate asynchronous response for updateCustomStyles
  } else {
    console.log("Unknown action received:", request.action);
    // Optional: send a response for unknown actions
    // sendResponse({ error: "Unknown action" });
    return false; // Synchronous response (or no response needed)
  }
});

// --- Initialization ---
// Ensure the style element exists on script load
console.log("Initializing content script...");
const styleElement = ensureStyleElementExists();

// Set initial state based on storage
chrome.storage.local.get(["stylesDisabled"], (result) => {
  const isDisabled = result.stylesDisabled || false; // Default to false if undefined
  if (styleElement) {
    styleElement.disabled = isDisabled;
    console.log(
      `Custom styles initial state set: ${isDisabled ? "DISABLED" : "ENABLED"}`
    );
  } else {
    console.error(
      "Failed to find or create style element during initialization."
    );
  }
});
